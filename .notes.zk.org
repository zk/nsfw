* 2012-12-17 Mon 20:55

Ok, looking to make serving a clojurescript app as easy as possible,
which means some helpers in webapp.

Let's look at the steps to get a clojurescript app running:

1. Modify =project.clj= to specify build parameters for the
   clojurescript file.
2. Establish a server, provide entry point
3. Specify routes to handle init of clojurescript app

Expanding on 3 we get:

1. HTML stuff -- title, js include, body tag, anything else? Dev mode
   for clojurescript repl?

Side note, it'd be cool to have a library to transform your
project.clj, how would this run, a bunch of shell scripts? Execute
from a link would be nice.  A general lien bootstrapper / code runner
would be cool, but the security implications are tough...


* 2012-12-23 Sun 21:18

Working on the frontend primitives thing.  Composable abstractions
ftw, but which are hiding on the frontend? Certainly, there seems to
be something about presentation / behavior.

D3 provides nice abstractions on top of the dom, and makes a couple of
things first class:

+ Add
+ Remove
+ Change

Change seems to be implicit in it's transform system current value ->
next value.


Selects also seem to play an important part.

It's intersting attaching data directly to the dom, mabye I'll try
that. However, maybe clojurescript atoms will do the trick enough
seems like it might be too much on large numbers of nodes.

However, there seems to be something about storing the data and the
change function directly on the 'node'.

Entry and exit, also interesting.

Attaching an atom directly to the node, as well as the function that
defines its rendering properties? interesting.  Then future select
functions can call the transfer function when updating.

Or the atom as the update trigger mechanism. Let's start with the
latter, because I'm closer to that.

Ok, lets see the parts

#+begin_src clojure

;; Attempt #1

(def header-val (atom "hello world"))

(def h1 ($ [:h1 "hello world"]))

(d/bind header-val (fn [o n]
                     (d/text h1 n)))

(d/append body h1)

(defn update []
  (reset! header-val (.random js/Math))
  (u/timeout update 1000))

(update)

#+end_src

Parts:

1. atom represeting data
2. dom element vis data
3. data bind, new values updates dom based on new value and update
   function.
4. data change function

Seems like 2 and 3 should be the core of the frontend declaration.



#+begin_src clojure

;; Attempt #2

(def val2 (atom "hello world 2"))

(def h2 ($ [:h2 @val2]))

(bind-el val2 h2 (fn [from to el]
                   (d/text el to)))

(update val2)

(d/append body h2)

#+end_src

Attempt #2 looks very similar to #1, with one important difference:
the function passed to =bind-el= dosen't need to have the el in scope,
decoupling the definition of the handler function from definition of
the element. This allows us to name certain operations, like =text=,
which will simply put the text of the updated data into the
element.


#+begin_src clojure

(defn update-text [from to el]
  (d/text el to))

#+end_src

This is still looking verbose, but we're making progress.  I think a
more real-world use case is that we'd be binding updates to a
sub-selection of nested clojure data structures. Better yet, can we
use the seq abstraction to simplify and make the sematics more clear?

Perhaps we can crib some of D3.

The baseline is modification from -> to on el.

What are the possible ops here?

+ replace
+ remove
+ update


So the problem now is that the rendering and the atom have to be on
the same 'level'.


* 2012-12-24 Mon 09:53

On the plane to honlulu.



* 2012-12-25 Tue 13:12

We've got some basic functionality down for the clojuredocs example. Is it readable?

It's not declarative, but what are we declaring? Well, what are the parts?

+ HTML / CSS -- provide the visuals, although with transitions and
  animations, css bleeds over to the action. 

Should we make the firing of events a bit easier? This would help us
decouple the input / text from what to do with it. Lets look at a text
input that executes a function when the text changes, but has stopped
changing for a specific time delta. Perhaps the behavior and the input
should be decoupled as well.

Hrm, maybe the event handlers should just be more and more
sophisticated.


#+begin_src clojure

(defn filter-input [result-vars-atom all-vars]
  (let [el ($ [:input.filter {:autofocus "autofocus"
                              :placeholder "regex power!"}])]
    (dom/keyup el (fn [e]
                    (reset! atom (->> el
                                      dom/val
                                      (match-vars vars)
                                      (take 20)))))
    el))


(defn filter-input [atom vars]
  (-> ($ e [:input.filter {:placeholder "filter here!"
                           :autofocus "autofocus"}])
      (dom/val-changed (fn [_ val]
                         (reset! atom (-> val
                                          (match-vars vars)
                                          (take 20)))))))


#+end_src

A bit cleaner.

Something that further hurts readability is the fact that the
functionality that determines how the matches get filtered is embedded
in the code. Reading top-down dosen't result in a lot of
understanding.

What are the things we need to do to write webapps?

+ Widgets
+ CRUD
+ Layout
+ Search
+ Social Integration
+ Rerendering when representational data changes.

Can we invert the chain here, we have to pass in the data atom, so can
we invert that? Firing events might be the way to go.

It seems like the code for handling that stuff should be separate,
listening for events and reacting?

Ok, lets change gears for a sec and look from the top down. How do we
describe the general layout?

It seems like the general idea should be verifyability -- as close to
production as possible.

Top down:

** Entry point

#+begin_src clojure

(defn main []
  (-> body
      (dom/append header)
      (dom/append (sidebar selected-vars))
      (dom/append (content selected-vars))))

#+end_src

Pretty good readability here, given the body, we're appending header,
sidebar and content sections.  Sidebar and content depend on the
passed in data =selected-vars=.  Can we improve things?

Making it more explicit, lets move all the state into =main=.

#+begin_src clojure

(defn main []
  (let [body ($ "body")
        vars (reader/read-string (.-functions js/window)) ; imported from page
        selected-vars (atom vars)] ; intially all vars are selected
    (-> body
        (dom/append header)
        (dom/append (sidebar selected-vars vars))
        (dom/append (content selected-vars)))))

#+end_src

Now all info needed to render this page is contained in the entry
point -- we have no state elsewhere, which is a good thing.


I was able to simplify =sidebar= a bit.

#+begin_src clojure

(defn bind-render [el atom rendering-fn]
  (dom/bind atom
            (fn [ident old new]
              (-> el dom/empty
                  (dom/append (rendering-fn new)))))
  el)

(defn sidebar [vars-atom vars]
  ($ [:div.sidebar
      [:div.filter-wrapper (filter-input vars-atom vars)]
      (-> ($ [:div.var-overviews
              (map var-overview vars)])
          (bind-render vars-atom
                       (fn [val] (map var-overview val))))]))

#+end_src


If I wanted to be super-explicit, I could name the different parts:

#+begin_src clojure

(defn filter-vars [vars-atom vars]
  ($ [:div.filter-wrapper
      (filter-input vars-atom vars)]))

(defn vars-overview [vars-atom vars]
  (-> ($ [:div.var-overviews
          (map var-overview vars)])
      (bind-render vars-atom (fn [val] (map var-overview val)))))

(defn sidebar [vars-atom vars]
  ($ [:div.sidebar
      (filter-vars vars-atom vars)
      (vars-overview vars-atom vars)]))

#+end_src



Now =content=

#+begin_src clojure

(defn render-var [{:keys [doc name arglists ns]}]
  ($ [:div.var
      [:h2.name name]
      [:div.doc doc]
      (when arglists
        [:div.arglists
         (->> arglists
              (map #(cons name %))
              (map #(vector :div (pr-str %)))
              (map $))])]))

(defn content [vars-atom]
  (let [el ($ [:div.content
               (map render-var @vars-atom)])]
    (dom/bind-el vars-atom
                 el
                 (fn [old new el]
                   (-> el
                       dom/empty
                       (dom/append (map render-var new)))))
    el))

;; |
;; v

(defn content [vars-atom]
  (-> ($ [:div.content (map render-var @vars-atom)])
      (bind-render vars-atom #(map render-var %))))

#+end_src


We're starting to define somewhat of a language for describing
widgets, we've got some state, a way to represent how that state
should look, and how that state should behave.


Eh, debatable if this is better than wiring everything up yourself:

#+begin_src clojure

(defn widget [state el vis]
  (-> ($ el)
      dom/empty
      (dom/append (vis @state))
      (bind-render state vis)))

(defn render-var [{:keys [doc name arglists ns]}]
  ($ [:div.var
      [:h2.name name]
      [:div.doc doc]
      (when arglists
        [:div.arglists
         (->> arglists
              (map #(cons name %))
              (map #(vector :div (pr-str %)))
              (map $))])]))

(defn content [vars-atom]
  (widget vars-atom
          [:div.content]
          #(map render-var %)))

#+end_src

Perhaps I need to make a choice as to whether MVC is the right call
here.

Simple to complex:

+ html
+ html + binding
+ html + binding + events (can't have events w/o binding?)

In each case you need the prev in scope, need to handle these three
cases in a composable way.

Why not couple the initial rendering to future updates? Often we want
to initially render a component differently (such as in a loading state).

#+begin_src clojure

;; Html

($ [:input.filter {:placeholder "filter here"}])

;; Html + Binding

(-> ($ [:div.name @name])
    (bind-el-new name (fn [el new] (dom/text el new))))

;; Html + Binding + Events

(defn bind-text [atom]
  (bind-el-new atom (fn [el new] (dom/text el new))))

(-> ($ [:div.click-count @clicks])
    (bind-text clicks)
    (click #(swap! clicks inc)))

#+end_src


Seems pretty composible, lets clean this up.

Seems like binding helpers are the way to go.


Cool idea: People input parameters that will work with a function, and
they're evaluated on the box, output is saved and shown, and rerun
periodically.


* 2012-12-26 Wed 16:27

Ok, onto the next example. Calling this one frowny. It's an app where
you can input stuff that bugs you.  Something bugging you a bunch of
time? Frowny will let you know and you can go fix it. Also you can
tell people _how_ you fixed it, also you can see what's bugging other
people, and how they fixed it.

This would be a great larger example -- Social integration, user
accounts, in addition to the frontend.


Might be a good point to clean up imports, lets see how annoying they are...

Ok, first pass done here: http://cl.ly/image/3b0f3v2w471R

The whole process was pretty smooth, spent a lot of time dicking with
bind-render because I didn't wrap =frowny= with a call to =dom/$=. I
should make that method safer, maybe auto wrap.

Pretty smooth sailing util I got to managing the rendering /
rerendering of the frownies section. Turns out my assumption about the
initial / rerendering was a bit off. Might want to take another look
at =widget=.

The essence of the problem is that I'm specifying the rendering
function twice:

#+begin_src clojure

(defn show-frownies [frownies]
  (-> (dom/$
       [:ol.frownies
        (if (> (count @frownies) 0)
          (map #(frowny frownies %) @frownies)
          [:h2 "No frownies!"])])
      (dom/bind-render frownies
                       (fn [fs] (map (fn [fs]
                                       (if (> (count @frownies) 0)
                                         (map #(frowny frownies %) @frownies)
                                         [:h2 "No frownies!"]))
                                     fs)))))

;; |
;; v

(defn show-frownies [frownies]
  (let [render (fn [fs] (map #(frowny frownies %) fs))]
    (-> (dom/$ [:ol.frownies (render @frownies)])
        (dom/bind-render frownies render))))

;; |
;; v

(defn show-frownies [frownies]
  (let [render (fn [fs] (map #(frowny frownies %) fs))]
    (-> (dom/$ [:ol.frownies])
        (dom/bind-render frownies render))))

#+end_src

When really (third code block) =bind-render= should call the render
function for you.

Working on shipping data back to the server -- created the
=push-updates= function, which will watch for changes to an atom on
the frontend, and send the updated state of the atom to the backend.

This is just a first cut, additional improvments could include just
sending diffs and error handling.  Really, it seems like I'm putting
the cart before the horse; the low-level data transfer functions
should be written first.

I'm pretty happy with this (d76dd77c4157d1607505ecbd27d41fded6c0ac66)
as a first cut.

https://github.com/zkim/nsfw/commit/d76dd77c4157d1607505ecbd27d41fded6c0ac66


* 2012-12-26 Wed 22:57

Revisiting the clojuredocs example to bring it up to date.


* 2012-12-27 Thu 11:53

Events, can we get away without them?


* 2012-12-27 Thu 16:52

Thinking about data transfer to the back-end. Probably want to support
operations on collections and maps:

** Collections

Operations:

+ Add el
+ Remove el
+ Update el
+ Paging


** Maps

+ Add key-val
+ Remove key-val
+ Update key-val


Pretty similar. I wonder if there's a performant way to diff and
update these data structures? How do nested updates work?

Working on a common function interface for the bind functions (past
bind itself). Think I've landed on =(fn [new old el] ...)=. Why that
order? It seems like the common case is to return something based on
the new state of the data.

Change =bind/update= in =vars-overview= to use =bind/render=

Seems like this is the correct order of things, because as we add more
specific helpers (=bind/update= -> =bind/render=) we reduce the
numbers of parameters required on the passed function.

#+begin_src clojure

(defn content [vars-atom]
  (-> ($ [:div.content (map render-var @vars-atom)])
      (bind/update vars-atom
                   (fn [new old el]
                     (-> el
                         dom/empty
                         (dom/append (map render-var new)))))))

(defn vars-overview [vars-atom vars]
  (-> ($ [:div.var-overviews
          (map var-overview vars)])
      (bind/update vars-atom
                   (fn [new old el]
                     (-> el
                         dom/empty
                         (dom/append (map var-overview new)))))))

;; |
;; v

(defn content [vars-atom]
  (-> ($ [:div.content (map render-var @vars-atom)])
      (bind/render vars-atom #(map render-var %))))

(defn vars-overview [vars-atom vars]
  (-> ($ [:div.var-overviews
          (map var-overview vars)])
      (bind/render vars-atom
                   #(map var-overview %))))

#+end_src


The =bind/render= also initially calls the render
function. It's convient, but might be a gotcha. Maybe that should be
moved to another function.


* 2013-01-08 Tue 20:36

Been making a lot of unfocused commits to NSFW. Neat stuff, but I
think I need to focus.  How about making NSFW a great environment to
build clojure webapps in?

+ Easy to get started
+ Ground-up library, piecemeal

I'll look to tackle the first one now.


* 2013-01-11 Fri 00:59

Need an option for reloading, what are the dev concerns?

+ Reload page when resources change
+ Reload code when clj files change

* 2013-01-12 Sat 12:19

Phases for working on NSFW

+ Generative structure.
  + Add / remove / modify files in lein-template folder
  + Test by =lein install=, =lein new nsfw <proj name>=
+ clj code
  + CRUD 
  + testing
  + nrepl
+ cljs code
  + CRUD
  + automated testing
  + refresher

+ code
+ tests (automated / manual)

Need to move google maps thing later, maybe move actual routes out to
reloadable namespace.


** Gen

+ <proj>.run
  + Entry point for app, sets up lifecycle stuff, server, imports
    config, etc


* 2013-01-12 Sat 20:53

Just finished deploy to heroku, steps:

1. =lein new nsfw nt=
2. =cd nt=
3. =git init=
4. =chmod u+x ./bin/build=
5. =git add -a -m 'initial'=
6. =heroku create nsfwtest=
7. =git push heroku master=

Can cut out the chmod, but feels really good.

Now that I've got a basis to work off of, time to clean up the
examples.

Wonder if I can symlink the clj and cljs dirs. Might provide a cleaner
interface to working on the docs site while not having to reinstall
the nsfw dep every time something changes.

i.e. this would provide separation between the doc site and nsfw
proper, but still provide for working on clj / cljs code.

* 2013-01-18 Fri 12:38

SCSS is source code, not assets


* 2013-01-21 Mon 19:58

Well, shit. Just spent a bunch of time reversing the direction of the
submodule include (nsfw containing nsfw-site to nsfw-site containing
nsfw), and it turns out it was cleaner the first time. Oh well,
sometimes you don't know til you go do something.

The good news is that it's super easy to get up and running.

It think the data transfer primitives are going to be a good core part
of NSFW. Push, pull and symetric.

Need to handle error cases on bind/push-updates

Maybe push-updates is premature. A more basic prim needs to follow the
http request / response cycle:

+ Client updates atom
+ Atom state is pushed to server
+ Atom state is optionally modified by response


View -> Server -> View -> Server

View -> Server -> View

Server -> View -> Server

Server -> View

View -> Server


Client -> Server

Server -> Client

Can the change be rejected on both?

Client -> Server -> Client

Server -> Client

I think c -> s is the major interaction mode we need to handle

c -> s -> c

c -> s : http fail (status), response fail (content)

Server state needs to be tracked as to not ship changes back to the
server.

c -> s

s -> c

c -> s -> c

s -> c -> s

Whatever it is, it's state tracked on the backend.

+ Client -> Server, aka Fire and Forget

Need a way to support saved state on server. Maybe client-server
interaction should be more fine-grained on the atom side.

Maybe serialized is the way to go

Checking serialization is neat, but need to close the gap somehow,
need to supply a callback for dirty / clean state

Dirty / Saved / Loading


Client  Server   Client
----------------------
Dirty | Saving | Saved

Can this be stored as metadata?

Client side stores state


* 2013-01-27 Sun 01:57

Working on bigboard, there's got to be a better way to structure the
view stuff. Essentially the following are all mixed together:

+ physical structure
+ event reaction
+ data binding
+ ui state

property change

old new el

change predicate


* 2013-01-27 Sun 13:29

render2 now takes functions as values for the el opts map, and for
html content. So when the backing atom's value changes, everything
gets rerendered automatically. It's a nice way to support static &
dynamic content & mix-and-match.

feels really fucking good

#+begin_src clojure

(defn render-item [!item]
  (bind/render
   (dom/$ [:li])
   !item
   (fn [{:keys [selected title editing
                body closed_at labels]}
        _ el]
     (when selected
       (dom/scroll-to el))
     (let [cls (if selected "selected" "")]
       [:div {:class (str "issue " cls)}
        [:h3.issue-title
         {:class (str "issue-title "
                      (if closed_at "closed" "open")
                      (if (> (count labels) 0) " has-labels"))}
         " "
         title]
        [:div.labels
         (if editing
           (render-edit-labels !item)
           (map render-label labels))]
        (when selected
          [:div.selected
           [:div.issue-body body]])
        (if editing
          #_(-> (dom/$ [:input])
                (dom/keyup (fn [e]
                             (dom/stop-prop e)
                             (dom/prevent e)
                             false))))]))))

(defn render-item [!item]
  (bind/render2
   !item
   [:li.issue
    {:classes (fn [{:keys [closed_at selected]}]
                [(if closed_at "closed" "open")
                 (when selected "selected")])}
    [:h3.issue-title
     {:classes (fn [v] (when (not (empty? (:labels v)))
                         ["has-labels"]))}
     :title]
    [:h4.labels
     (fn [{:keys [editing labels]}]
       (if editing
         (render-edit-labels !item)
         (when (not (empty? labels))
           (map render-label labels))))]
    (fn [{:keys [selected body]}]
      (when selected
        [:div.body body]))]
   (fn [new old el]
     (when (:selected new)
       (dom/scroll-to el)))))


#+end_src


* 2013-02-27 Wed 19:45

Goals for tonight:

1. Change refresher to only refresh the first chrome tab, not the
   top-most.
2. Work on css3 animation framework

The animation framework should let you easily transition properties on
elements using css3. Taking a lot of inspiration from emile.js.

* 2013-03-01 Fri 23:10

Responsive design.

Box sizing: http://paulirish.com/2012/box-sizing-border-box-ftw/


* 2013-03-04 Mon 18:13

With routes, there should be some common setup, init routes which
watches for changes on the hash and loads new content when the page
changes.

Challenges: How is global set up handled?

The idea is:

1. There's some common page setup, maybe initialization of query
   services, polling, websockets connections, whatever. Stuff that's
   common to the entire lifecycle of the app.

2. There's per-route setup.


Q: what's the right level of setup done by the initial page load / vs
subsequent js 'page' changes. Should be as easy to make single page
apps as it is to make more traditional 'dynamically enhanced' apps.

What's this mean for routing? Seems like a lot of bookkeeping you have
to do manually.

I'm worried that the overhead of shipping an entire app in one js page
might not be feasable, even with dead code removal.

Maybe I should be opinionated here -- There's one backend route that
ships the entire application, and all other routes are api routes.

I'm pretty comfortable with that for now. Clojurescript app at
root. What about the loader script?

Since we put js tags in the body, the initial page load structure
should ship the loading screen, then get wiped out as a first action
by the javascript.  So, we need to have a nice way of providing the
loading screen. Let's look at that now. `webapp.cs` should default to
a nice nsfw loading screen, with the ability to override.

Ok, so now we're shipping a loading screen, but the jump is pretty
jarring. Fade out / fade in? Also, if you're dynamically loading data
in the background that's two jumps. Perhaps a way to signal that the
initial UI is ready to be viewed?

Meh, I'm on the fence on this. It's nice to have the animated
transition, but it's clear that the transition should only happen on
initial page load. Also, maybe it should only load if the :loading
opt is set on `webapp/cs`. If this is the case, then we'll need to
provide some page load helper. So what goes into page load?

+ Getting a handle on data injected into the page
+ Initial js transfer and load.
+ Initial background color for load

Looks like we need to make some state available for the page. This
feels good though, we're starting at the beginning.

JHC just spent the last hour tracking down an Undefined Identifier
error, no line number. Ended up being I was passing in something to
util/timeout without wrapping it in a function first. AARRRGGGGHHH.

Ok so it looks like loading is a non-issue, it dosen't seem like
there's a reliable way to get some page content to load before the js
anyway, so any HTML shipped wouldn't show anyway. It's important to
keep the js as small as possible though, so that's something I'll have
to make easy. Revised initial stuff below:

+ Initial background color for load
+ Getting a handle on data injected into the page
+ Initial js transfer and load.


Order of ops
+ Request comes in
+ One route for the app
+ Load the 


+ App Setup
  + Clojurescript app
    + Session storage
    + entry ns
    + route handling
    + css
    + extra js
  + handles all traffic (push state)
    + has the ability to pretty seriously break 404, as all your
      routes will resolve as a 200 now. Perhaps can handle this with a
      route whitelist, patterns of valid pages.
  + API slug, everything there is handled by api routes



** New clojurescript app syntax

#+begin_src clojure

(def routes
  (app/clojurescript
   :session-atom session-atom
   :entry 'bigboard.app/entry
   :css   [:bootstrap.min :bootstrap-responsive.min :app]
   :data  (fn [r]
            {:issues (take 10 @!gh-issues)
             :user (when-let [gh-user (-> r :session :gh-user)] gh-user)})
   :api (app/route
         ["label-ac"] (label-ac !gh-issues !gh-labels)
         ["issues" number] {:post (post-issue !gh-issues number)}
         ["issues"]        (fn [{:keys [params]}]
                             (let [{:keys [d t] :or {d 0 t 10}} params]
                               {:body (pr-str (->> @!gh-issues
                                                   (drop (nu/parse-int d))
                                                   (take (nu/parse-int t))))})))))

#+end_src

* NSFW (No Such Framework)

A library to lower the friction associated with building
production-quality internet apps.


* 2012-12-17 Mon 20:55

Ok, looking to make serving a clojurescript app as easy as possible,
which means some helpers in webapp.

Let's look at the steps to get a clojurescript app running:

1. Modify =project.clj= to specify build parameters for the
   clojurescript file.
2. Establish a server, provide entry point
3. Specify routes to handle init of clojurescript app

Expanding on 3 we get:

1. HTML stuff -- title, js include, body tag, anything else? Dev mode
   for clojurescript repl?

Side note, it'd be cool to have a library to transform your
project.clj, how would this run, a bunch of shell scripts? Execute
from a link would be nice.  A general lien bootstrapper / code runner
would be cool, but the security implications are tough...


* 2012-12-23 Sun 21:18

Working on the frontend primitives thing.  Composable abstractions
ftw, but which are hiding on the frontend? Certainly, there seems to
be something about presentation / behavior.

D3 provides nice abstractions on top of the dom, and makes a couple of
things first class:

+ Add
+ Remove
+ Change

Change seems to be implicit in it's transform system current value ->
next value.


Selects also seem to play an important part.

It's intersting attaching data directly to the dom, mabye I'll try
that. However, maybe clojurescript atoms will do the trick enough
seems like it might be too much on large numbers of nodes.

However, there seems to be something about storing the data and the
change function directly on the 'node'.

Entry and exit, also interesting.

Attaching an atom directly to the node, as well as the function that
defines its rendering properties? interesting.  Then future select
functions can call the transfer function when updating.

Or the atom as the update trigger mechanism. Let's start with the
latter, because I'm closer to that.

Ok, lets see the parts

#+begin_src clojure

;; Attempt #1

(def header-val (atom "hello world"))

(def h1 ($ [:h1 "hello world"]))

(d/bind header-val (fn [o n]
                     (d/text h1 n)))

(d/append body h1)

(defn update []
  (reset! header-val (.random js/Math))
  (u/timeout update 1000))

(update)

#+end_src

Parts:

1. atom represeting data
2. dom element vis data
3. data bind, new values updates dom based on new value and update
   function.
4. data change function

Seems like 2 and 3 should be the core of the frontend declaration.



#+begin_src clojure

;; Attempt #2

(def val2 (atom "hello world 2"))

(def h2 ($ [:h2 @val2]))

(bind-el val2 h2 (fn [from to el]
                   (d/text el to)))

(update val2)

(d/append body h2)

#+end_src

Attempt #2 looks very similar to #1, with one important difference:
the function passed to =bind-el= dosen't need to have the el in scope,
decoupling the definition of the handler function from definition of
the element. This allows us to name certain operations, like =text=,
which will simply put the text of the updated data into the
element.


#+begin_src clojure

(defn update-text [from to el]
  (d/text el to))

#+end_src

This is still looking verbose, but we're making progress.  I think a
more real-world use case is that we'd be binding updates to a
sub-selection of nested clojure data structures. Better yet, can we
use the seq abstraction to simplify and make the sematics more clear?

Perhaps we can crib some of D3.

The baseline is modification from -> to on el.

What are the possible ops here?

+ replace
+ remove
+ update


So the problem now is that the rendering and the atom have to be on
the same 'level'.


* 2012-12-24 Mon 09:53

On the plane to honlulu.



* 2012-12-25 Tue 13:12

We've got some basic functionality down for the clojuredocs example. Is it readable?

It's not declarative, but what are we declaring? Well, what are the parts?

+ HTML / CSS -- provide the visuals, although with transitions and
  animations, css bleeds over to the action.

Should we make the firing of events a bit easier? This would help us
decouple the input / text from what to do with it. Lets look at a text
input that executes a function when the text changes, but has stopped
changing for a specific time delta. Perhaps the behavior and the input
should be decoupled as well.

Hrm, maybe the event handlers should just be more and more
sophisticated.


#+begin_src clojure

(defn filter-input [result-vars-atom all-vars]
  (let [el ($ [:input.filter {:autofocus "autofocus"
                              :placeholder "regex power!"}])]
    (dom/keyup el (fn [e]
                    (reset! atom (->> el
                                      dom/val
                                      (match-vars vars)
                                      (take 20)))))
    el))


(defn filter-input [atom vars]
  (-> ($ e [:input.filter {:placeholder "filter here!"
                           :autofocus "autofocus"}])
      (dom/val-changed (fn [_ val]
                         (reset! atom (-> val
                                          (match-vars vars)
                                          (take 20)))))))


#+end_src

A bit cleaner.

Something that further hurts readability is the fact that the
functionality that determines how the matches get filtered is embedded
in the code. Reading top-down dosen't result in a lot of
understanding.

What are the things we need to do to write webapps?

+ Widgets
+ CRUD
+ Layout
+ Search
+ Social Integration
+ Rerendering when representational data changes.

Can we invert the chain here, we have to pass in the data atom, so can
we invert that? Firing events might be the way to go.

It seems like the code for handling that stuff should be separate,
listening for events and reacting?

Ok, lets change gears for a sec and look from the top down. How do we
describe the general layout?

It seems like the general idea should be verifyability -- as close to
production as possible.

Top down:

** Entry point

#+begin_src clojure

(defn main []
  (-> body
      (dom/append header)
      (dom/append (sidebar selected-vars))
      (dom/append (content selected-vars))))

#+end_src

Pretty good readability here, given the body, we're appending header,
sidebar and content sections.  Sidebar and content depend on the
passed in data =selected-vars=.  Can we improve things?

Making it more explicit, lets move all the state into =main=.

#+begin_src clojure

(defn main []
  (let [body ($ "body")
        vars (reader/read-string (.-functions js/window)) ; imported from page
        selected-vars (atom vars)] ; intially all vars are selected
    (-> body
        (dom/append header)
        (dom/append (sidebar selected-vars vars))
        (dom/append (content selected-vars)))))

#+end_src

Now all info needed to render this page is contained in the entry
point -- we have no state elsewhere, which is a good thing.


I was able to simplify =sidebar= a bit.

#+begin_src clojure

(defn bind-render [el atom rendering-fn]
  (dom/bind atom
            (fn [ident old new]
              (-> el dom/empty
                  (dom/append (rendering-fn new)))))
  el)

(defn sidebar [vars-atom vars]
  ($ [:div.sidebar
      [:div.filter-wrapper (filter-input vars-atom vars)]
      (-> ($ [:div.var-overviews
              (map var-overview vars)])
          (bind-render vars-atom
                       (fn [val] (map var-overview val))))]))

#+end_src


If I wanted to be super-explicit, I could name the different parts:

#+begin_src clojure

(defn filter-vars [vars-atom vars]
  ($ [:div.filter-wrapper
      (filter-input vars-atom vars)]))

(defn vars-overview [vars-atom vars]
  (-> ($ [:div.var-overviews
          (map var-overview vars)])
      (bind-render vars-atom (fn [val] (map var-overview val)))))

(defn sidebar [vars-atom vars]
  ($ [:div.sidebar
      (filter-vars vars-atom vars)
      (vars-overview vars-atom vars)]))

#+end_src



Now =content=

#+begin_src clojure

(defn render-var [{:keys [doc name arglists ns]}]
  ($ [:div.var
      [:h2.name name]
      [:div.doc doc]
      (when arglists
        [:div.arglists
         (->> arglists
              (map #(cons name %))
              (map #(vector :div (pr-str %)))
              (map $))])]))

(defn content [vars-atom]
  (let [el ($ [:div.content
               (map render-var @vars-atom)])]
    (dom/bind-el vars-atom
                 el
                 (fn [old new el]
                   (-> el
                       dom/empty
                       (dom/append (map render-var new)))))
    el))

;; |
;; v

(defn content [vars-atom]
  (-> ($ [:div.content (map render-var @vars-atom)])
      (bind-render vars-atom #(map render-var %))))

#+end_src


We're starting to define somewhat of a language for describing
widgets, we've got some state, a way to represent how that state
should look, and how that state should behave.


Eh, debatable if this is better than wiring everything up yourself:

#+begin_src clojure

(defn widget [state el vis]
  (-> ($ el)
      dom/empty
      (dom/append (vis @state))
      (bind-render state vis)))

(defn render-var [{:keys [doc name arglists ns]}]
  ($ [:div.var
      [:h2.name name]
      [:div.doc doc]
      (when arglists
        [:div.arglists
         (->> arglists
              (map #(cons name %))
              (map #(vector :div (pr-str %)))
              (map $))])]))

(defn content [vars-atom]
  (widget vars-atom
          [:div.content]
          #(map render-var %)))

#+end_src

Perhaps I need to make a choice as to whether MVC is the right call
here.

Simple to complex:

+ html
+ html + binding
+ html + binding + events (can't have events w/o binding?)

In each case you need the prev in scope, need to handle these three
cases in a composable way.

Why not couple the initial rendering to future updates? Often we want
to initially render a component differently (such as in a loading state).

#+begin_src clojure

;; Html

($ [:input.filter {:placeholder "filter here"}])

;; Html + Binding

(-> ($ [:div.name @name])
    (bind-el-new name (fn [el new] (dom/text el new))))

;; Html + Binding + Events

(defn bind-text [atom]
  (bind-el-new atom (fn [el new] (dom/text el new))))

(-> ($ [:div.click-count @clicks])
    (bind-text clicks)
    (click #(swap! clicks inc)))

#+end_src


Seems pretty composible, lets clean this up.

Seems like binding helpers are the way to go.


Cool idea: People input parameters that will work with a function, and
they're evaluated on the box, output is saved and shown, and rerun
periodically.


* 2012-12-26 Wed 16:27

Ok, onto the next example. Calling this one frowny. It's an app where
you can input stuff that bugs you.  Something bugging you a bunch of
time? Frowny will let you know and you can go fix it. Also you can
tell people _how_ you fixed it, also you can see what's bugging other
people, and how they fixed it.

This would be a great larger example -- Social integration, user
accounts, in addition to the frontend.


Might be a good point to clean up imports, lets see how annoying they are...

Ok, first pass done here: http://cl.ly/image/3b0f3v2w471R

The whole process was pretty smooth, spent a lot of time dicking with
bind-render because I didn't wrap =frowny= with a call to =dom/$=. I
should make that method safer, maybe auto wrap.

Pretty smooth sailing util I got to managing the rendering /
rerendering of the frownies section. Turns out my assumption about the
initial / rerendering was a bit off. Might want to take another look
at =widget=.

The essence of the problem is that I'm specifying the rendering
function twice:

#+begin_src clojure

(defn show-frownies [frownies]
  (-> (dom/$
       [:ol.frownies
        (if (> (count @frownies) 0)
          (map #(frowny frownies %) @frownies)
          [:h2 "No frownies!"])])
      (dom/bind-render frownies
                       (fn [fs] (map (fn [fs]
                                       (if (> (count @frownies) 0)
                                         (map #(frowny frownies %) @frownies)
                                         [:h2 "No frownies!"]))
                                     fs)))))

;; |
;; v

(defn show-frownies [frownies]
  (let [render (fn [fs] (map #(frowny frownies %) fs))]
    (-> (dom/$ [:ol.frownies (render @frownies)])
        (dom/bind-render frownies render))))

;; |
;; v

(defn show-frownies [frownies]
  (let [render (fn [fs] (map #(frowny frownies %) fs))]
    (-> (dom/$ [:ol.frownies])
        (dom/bind-render frownies render))))

#+end_src

When really (third code block) =bind-render= should call the render
function for you.

Working on shipping data back to the server -- created the
=push-updates= function, which will watch for changes to an atom on
the frontend, and send the updated state of the atom to the backend.

This is just a first cut, additional improvments could include just
sending diffs and error handling.  Really, it seems like I'm putting
the cart before the horse; the low-level data transfer functions
should be written first.

I'm pretty happy with this (d76dd77c4157d1607505ecbd27d41fded6c0ac66)
as a first cut.

https://github.com/zkim/nsfw/commit/d76dd77c4157d1607505ecbd27d41fded6c0ac66


* 2012-12-26 Wed 22:57

Revisiting the clojuredocs example to bring it up to date.


* 2012-12-27 Thu 11:53

Events, can we get away without them?


* 2012-12-27 Thu 16:52

Thinking about data transfer to the back-end. Probably want to support
operations on collections and maps:

** Collections

Operations:

+ Add el
+ Remove el
+ Update el
+ Paging


** Maps

+ Add key-val
+ Remove key-val
+ Update key-val


Pretty similar. I wonder if there's a performant way to diff and
update these data structures? How do nested updates work?

Working on a common function interface for the bind functions (past
bind itself). Think I've landed on =(fn [new old el] ...)=. Why that
order? It seems like the common case is to return something based on
the new state of the data.

Change =bind/update= in =vars-overview= to use =bind/render=

Seems like this is the correct order of things, because as we add more
specific helpers (=bind/update= -> =bind/render=) we reduce the
numbers of parameters required on the passed function.

#+begin_src clojure

(defn content [vars-atom]
  (-> ($ [:div.content (map render-var @vars-atom)])
      (bind/update vars-atom
                   (fn [new old el]
                     (-> el
                         dom/empty
                         (dom/append (map render-var new)))))))

(defn vars-overview [vars-atom vars]
  (-> ($ [:div.var-overviews
          (map var-overview vars)])
      (bind/update vars-atom
                   (fn [new old el]
                     (-> el
                         dom/empty
                         (dom/append (map var-overview new)))))))

;; |
;; v

(defn content [vars-atom]
  (-> ($ [:div.content (map render-var @vars-atom)])
      (bind/render vars-atom #(map render-var %))))

(defn vars-overview [vars-atom vars]
  (-> ($ [:div.var-overviews
          (map var-overview vars)])
      (bind/render vars-atom
                   #(map var-overview %))))

#+end_src


The =bind/render= also initially calls the render
function. It's convient, but might be a gotcha. Maybe that should be
moved to another function.


* 2013-01-08 Tue 20:36

Been making a lot of unfocused commits to NSFW. Neat stuff, but I
think I need to focus.  How about making NSFW a great environment to
build clojure webapps in?

+ Easy to get started
+ Ground-up library, piecemeal

I'll look to tackle the first one now.


* 2013-01-11 Fri 00:59

Need an option for reloading, what are the dev concerns?

+ Reload page when resources change
+ Reload code when clj files change

* 2013-01-12 Sat 12:19

Phases for working on NSFW

+ Generative structure.
  + Add / remove / modify files in lein-template folder
  + Test by =lein install=, =lein new nsfw <proj name>=
+ clj code
  + CRUD
  + testing
  + nrepl
+ cljs code
  + CRUD
  + automated testing
  + refresher

+ code
+ tests (automated / manual)

Need to move google maps thing later, maybe move actual routes out to
reloadable namespace.


** Gen

+ <proj>.run
  + Entry point for app, sets up lifecycle stuff, server, imports
    config, etc


* 2013-01-12 Sat 20:53

Just finished deploy to heroku, steps:

1. =lein new nsfw nt=
2. =cd nt=
3. =git init=
4. =chmod u+x ./bin/build=
5. =git add -a -m 'initial'=
6. =heroku create nsfwtest=
7. =git push heroku master=

Can cut out the chmod, but feels really good.

Now that I've got a basis to work off of, time to clean up the
examples.

Wonder if I can symlink the clj and cljs dirs. Might provide a cleaner
interface to working on the docs site while not having to reinstall
the nsfw dep every time something changes.

i.e. this would provide separation between the doc site and nsfw
proper, but still provide for working on clj / cljs code.

* 2013-01-18 Fri 12:38

SCSS is source code, not assets


* 2013-01-21 Mon 19:58

Well, shit. Just spent a bunch of time reversing the direction of the
submodule include (nsfw containing nsfw-site to nsfw-site containing
nsfw), and it turns out it was cleaner the first time. Oh well,
sometimes you don't know til you go do something.

The good news is that it's super easy to get up and running.

It think the data transfer primitives are going to be a good core part
of NSFW. Push, pull and symetric.

Need to handle error cases on bind/push-updates

Maybe push-updates is premature. A more basic prim needs to follow the
http request / response cycle:

+ Client updates atom
+ Atom state is pushed to server
+ Atom state is optionally modified by response


View -> Server -> View -> Server

View -> Server -> View

Server -> View -> Server

Server -> View

View -> Server


Client -> Server

Server -> Client

Can the change be rejected on both?

Client -> Server -> Client

Server -> Client

I think c -> s is the major interaction mode we need to handle

c -> s -> c

c -> s : http fail (status), response fail (content)

Server state needs to be tracked as to not ship changes back to the
server.

c -> s

s -> c

c -> s -> c

s -> c -> s

Whatever it is, it's state tracked on the backend.

+ Client -> Server, aka Fire and Forget

Need a way to support saved state on server. Maybe client-server
interaction should be more fine-grained on the atom side.

Maybe serialized is the way to go

Checking serialization is neat, but need to close the gap somehow,
need to supply a callback for dirty / clean state

Dirty / Saved / Loading


Client  Server   Client
----------------------
Dirty | Saving | Saved

Can this be stored as metadata?

Client side stores state


* 2013-01-27 Sun 01:57

Working on bigboard, there's got to be a better way to structure the
view stuff. Essentially the following are all mixed together:

+ physical structure
+ event reaction
+ data binding
+ ui state

property change

old new el

change predicate


* 2013-01-27 Sun 13:29

render2 now takes functions as values for the el opts map, and for
html content. So when the backing atom's value changes, everything
gets rerendered automatically. It's a nice way to support static &
dynamic content & mix-and-match.

feels really fucking good

#+begin_src clojure

(defn render-item [!item]
  (bind/render
   (dom/$ [:li])
   !item
   (fn [{:keys [selected title editing
                body closed_at labels]}
        _ el]
     (when selected
       (dom/scroll-to el))
     (let [cls (if selected "selected" "")]
       [:div {:class (str "issue " cls)}
        [:h3.issue-title
         {:class (str "issue-title "
                      (if closed_at "closed" "open")
                      (if (> (count labels) 0) " has-labels"))}
         " "
         title]
        [:div.labels
         (if editing
           (render-edit-labels !item)
           (map render-label labels))]
        (when selected
          [:div.selected
           [:div.issue-body body]])
        (if editing
          #_(-> (dom/$ [:input])
                (dom/keyup (fn [e]
                             (dom/stop-prop e)
                             (dom/prevent e)
                             false))))]))))

(defn render-item [!item]
  (bind/render2
   !item
   [:li.issue
    {:classes (fn [{:keys [closed_at selected]}]
                [(if closed_at "closed" "open")
                 (when selected "selected")])}
    [:h3.issue-title
     {:classes (fn [v] (when (not (empty? (:labels v)))
                         ["has-labels"]))}
     :title]
    [:h4.labels
     (fn [{:keys [editing labels]}]
       (if editing
         (render-edit-labels !item)
         (when (not (empty? labels))
           (map render-label labels))))]
    (fn [{:keys [selected body]}]
      (when selected
        [:div.body body]))]
   (fn [new old el]
     (when (:selected new)
       (dom/scroll-to el)))))


#+end_src


* 2013-02-27 Wed 19:45

Goals for tonight:

1. Change refresher to only refresh the first chrome tab, not the
   top-most.
2. Work on css3 animation framework

The animation framework should let you easily transition properties on
elements using css3. Taking a lot of inspiration from emile.js.

* 2013-03-01 Fri 23:10

Responsive design.

Box sizing: http://paulirish.com/2012/box-sizing-border-box-ftw/


* 2013-03-04 Mon 18:13

With routes, there should be some common setup, init routes which
watches for changes on the hash and loads new content when the page
changes.

Challenges: How is global set up handled?

The idea is:

1. There's some common page setup, maybe initialization of query
   services, polling, websockets connections, whatever. Stuff that's
   common to the entire lifecycle of the app.

2. There's per-route setup.


Q: what's the right level of setup done by the initial page load / vs
subsequent js 'page' changes. Should be as easy to make single page
apps as it is to make more traditional 'dynamically enhanced' apps.

What's this mean for routing? Seems like a lot of bookkeeping you have
to do manually.

I'm worried that the overhead of shipping an entire app in one js page
might not be feasable, even with dead code removal.

Maybe I should be opinionated here -- There's one backend route that
ships the entire application, and all other routes are api routes.

I'm pretty comfortable with that for now. Clojurescript app at
root. What about the loader script?

Since we put js tags in the body, the initial page load structure
should ship the loading screen, then get wiped out as a first action
by the javascript.  So, we need to have a nice way of providing the
loading screen. Let's look at that now. `webapp.cs` should default to
a nice nsfw loading screen, with the ability to override.

Ok, so now we're shipping a loading screen, but the jump is pretty
jarring. Fade out / fade in? Also, if you're dynamically loading data
in the background that's two jumps. Perhaps a way to signal that the
initial UI is ready to be viewed?

Meh, I'm on the fence on this. It's nice to have the animated
transition, but it's clear that the transition should only happen on
initial page load. Also, maybe it should only load if the :loading
opt is set on `webapp/cs`. If this is the case, then we'll need to
provide some page load helper. So what goes into page load?

+ Getting a handle on data injected into the page
+ Initial js transfer and load.
+ Initial background color for load

Looks like we need to make some state available for the page. This
feels good though, we're starting at the beginning.

JHC just spent the last hour tracking down an Undefined Identifier
error, no line number. Ended up being I was passing in something to
util/timeout without wrapping it in a function first. AARRRGGGGHHH.

Ok so it looks like loading is a non-issue, it dosen't seem like
there's a reliable way to get some page content to load before the js
anyway, so any HTML shipped wouldn't show anyway. It's important to
keep the js as small as possible though, so that's something I'll have
to make easy. Revised initial stuff below:

+ Initial background color for load
+ Getting a handle on data injected into the page
+ Initial js transfer and load.

Order of ops
+ Request comes in
+ One route for the app
+ Load the

+ App Setup
  + Clojurescript app
    + Session storage
    + entry ns
    + route handling
    + css
    + extra js
  + handles all traffic (push state)
    + has the ability to pretty seriously break 404, as all your
      routes will resolve as a 200 now. Perhaps can handle this with a
      route whitelist, patterns of valid pages.
  + API slug, everything there is handled by api routes



** New clojurescript app syntax

#+begin_src clojure

(def routes
  (app/clojurescript
   :session-atom session-atom
   :entry 'bigboard.app/entry
   :css   [:bootstrap.min :bootstrap-responsive.min :app]
   :data  (fn [r]
            {:issues (take 10 @!gh-issues)
             :user (when-let [gh-user (-> r :session :gh-user)] gh-user)})
   :api (app/route
         ["label-ac"] (label-ac !gh-issues !gh-labels)
         ["issues" number] {:post (post-issue !gh-issues number)}
         ["issues"]        (fn [{:keys [params]}]
                             (let [{:keys [d t] :or {d 0 t 10}} params]
                               {:body (pr-str (->> @!gh-issues
                                                   (drop (nu/parse-int d))
                                                   (take (nu/parse-int t))))})))))

#+end_src


* <2013-03-08 Fri 16:49>

Pain points:

+ Form validation
+ Loading state
  + global (whole page loader) / local (specific element)


Colors pulled from http://pinterest.com/pin/135671007496518737/

* <2013-03-09 Sat 13:40>

Working on the data interface. Work with the grain of http.

GET - Query
POST - New
PATCH - Update entity
PUT - Full update

Don't really use put, patch instead

Two basic common operations, query and post info

Query needs to be send along with the body of the request

edn in a query parameter?


* <2013-03-09 Sat 18:55>

Working on the server stuff still, trying to get super clean on it,
basically I need to define what's the important stuff here.

Local changes should be persisted to the server, only caring about
response code (success or failure). At it's simplest version there's
no update from the server.

sever-push -- takes the atom representing state, options (method,
path, etc), and a function which determines whether or not to send to
the server.

get vs post vs put vs patch

get - single / collection
post - single / collection
put - single / collection
patch - single / collection

Also need a predicate to tell when to transmit data? Are atoms the
right thing for this?

+ piece of data
+ watch for changes
+ know when to send to server

Where is the code for sending the new thing to the server? It seems to
be apart from the presentation, but that's where all the error
handling logic needs to go in the case where the user has to be
notified of a failure.

So we've got a collection of items that's being watched. How bout a
couple of places being a possibility?

1. Keep all logic local to the preso / event handling code, assume the
   thing is on the server when it makes it into the collection.
2. Add logic to the collection to which the thing gets added. Assume
   success and remove if that's not the case (it seems like you need
   to know why it was removed).


Overall, the opinion is keep validations on the client (still need to
validate on server for data integrity / rules), keep a handle to the
new thing until the server response comes back 200. So it's #2, and
this is to make the user experience better, and I'm ok with the
assumption that failures on the server will be the edge case assuming
the data passes local validation.

There are three cases when you consider the single / coll perspective:

1. Add single record to collection, single record is rendered,
   collection saves to server, everything is ok. Like
   this because it separates the preso / data logic.
2. Add single record, single rendered, collection saves to server,
   failure, single removed from collection, single rendering removed
   from DOM.

One potential downside is that you lose the diff at the source, so it
may be expensive to calculate the diff. May have enough of a handle to
make this ok.

It seems like the diff structure needs to be a first class thing, so
you can reverse changes you assume to work when you find out they
didn't. Very similar to an undo stack.


* <2013-03-11 Mon 23:37>

I really enjoyed reading
http://www.chris-granger.com/2013/01/24/the-ide-as-data/ and it got me
thinking of how coupled everything is in NSFW right now. I've got
functions that conflate everything, but what is everything?

+ event handlers
+ elements
+ application data
+ external communication

Let's take permrec as an example.

I've got an input (element), and when the value of this input changes
I want to fetch records matching the input's text and display them in
an area under the input.

+ event handlers
  + input keydown
+ elements
  + input el
  + results area
+ application data
  + input value
  + matching records
+ external comm
  + hit server for records (async)


data can be a value, function or atom

value -- rendered normally
function -- called with some context
atom -- bind for changes

Values aren't interesting, just embed them into the dom?

Part of the problem with using changes to the data atom to push
changes to the server is that multiple locatons can be bound to update
data, both locally and on the server.

Whos responsbility is it to update the server? How does that thing
communicate success / failure? Events? Seems reasonable. Things need
to be either values or functions or atoms.

Binding of values happens at call time through the use of
functions. Let's make time a thing.

Ok, this feels pretty good. Composable behavoir.

Types of changes
+ t (pure)
+ updates to $el

Naming selectors?

1. Set up
2. Respond to events

Composibility / introspection

Composibility
+ collection
+ nesting

Introspection
+ Single point of change / state


* <2013-03-15 Fri 16:55>

What's the basic concept here? Functions modifying maps I think.

Maps representing some state about the widget, things being run when
state gets modified? Can we put a general rule around functions being
executed?

Having an atom in the map feels weird, but that can just be server
state / long range communication stuff. Local changes to the map don't
have event callbacks?


* <2013-03-17 Sun 16:24>

Ok, I want to know what the structure and behavior is for the element
(preso is not a concern here.)

Kind of stuck here, how to handle the long-range comm problem?

ARRRRRRGGGGGGHHHHHHHHH

init - puts extra data on map

Ok, behaviors work off of state

Why not just use dom props? Well, we need a system that can do both.

Use selectors as names

What it _is_ and what it _does_

I like the idea of the whole thing being available

render behavior


Ok, how do we apply the good things about functional programming
(immutability, composition, purity) with dom programming? I want to
say that state is managed by the framework, but I don't think that's
right.

Declaration is good.

Some way to hook back to the larger state

Start at the top

Value transitions

add remove update

d3?


Simple -> Complex

+ HTML rendered as DOM
+ HTML w/ events
+ HTML w/ data callbacks

Let's add a functional interface on top

Ok, let's get really crisp on what this is and what's important:

Declarative -- what not how


dom, events, data

Specifying css selectors

+ "#foo.bar baz"
+ :#foo.bar
+ [:#foo "bar.baz" :.bap"]

So you want to deal with the element itself, plus the data and work
through events on the data.

Need a richer change api, additions, removals changes (by position?)

+ Maps: keys changed, from what to what

{:key [from-val to-val]}
{:key {:from val :to val}}

Tough to do nested in this way, need to figure out the questions that
would be asked.


one el, one atom

can they be decoupled by async?

Ok, feel pretty good. Next.


* <2013-03-21 Thu 15:23>

Think we're gonna need some sort of introspection on the events stuff,
running into a thing where the ordering of event handlers across
multiple behavior functions is causing a bug. Need a way to visualize
that.


<2015-02-02 Mon 16:23>

Hey old friend, I'm back!

Learned a lot about clojure web dev over the past couple of
years, and have finally gotten frustrated enough at hand-rolling
dozens of times to put stuff back in this lib.

On a side note, It's really interesting to read through some of the
history here.

Starting over, somewhat from scratch. Some things have changed, like
clojurescript dev via figwheel, the new ubiquity of react, and the
desire for async by default. The addition of mobile dev via Vee makes
things a bit more interesting.


Some notes on how my dev tooling has changed.

+ Still using emacs, but there are some good options on the
  horizon. Cursive is the stand-out.
+ I've somewhat adopted the tools.namespace stuff into my workflow,
  hopefully some of the rough edges will get ironed out eventually.
+ HTML generation is now pretty much exculsively done on the frontend,
  not to say there aren't still facilities for server-side
  rendering. Right now that means hiccup, but hopefully React will get
  ported to the JVM soon.
+ I've switched from doing CSS generation via the nsfw.html namespace
  to Sass, and now to LESS. Still have hopes for using Clojure to
  generate CSS, as it obviates the need to learn a separate language.


Some stuff has held up nicely:

+ nsfw.env is great, have used it, or something like it on virtually
  every project I've done in the past 2 years.
+ Util is pretty good, especially `timeago`.
+ GitHub auth helpers are really nice.
+ Putting things in the request map is a good way to carry context
  through the handling chain.
+ Some date stuff, specifically iso-8601 handling.


Some general thoughts as I peruse the codebase:

+ There's so much stuff here, need to focus on reducing the API
  surface area. The ideal number of functions in an API is 0.
+ Providing a collection of default middleware is a good idea. So much
  frustration from `use`ing all the disparate middleware
  namespaces. Hard to fault the ring author as the API reflects best
  practices from when the lib was written.
+ Refresher is still interesting, but possible not done at the code
  level. There are tools like LiveReload that will watch a file tree
  and refresh the browser. Also partially conflicts with Figwheel.
+ Routes + documentation seems like a good idea. There are a few
  places to put this, including in-structure and metadata. The goal
  here is a flexible routing structure that supports web and API
  routes with documentation. In other words, routes should be
  self-documenting.
+ nsfw.server will change completely. Backending into an async
  framework like aleph changes the whole API.


Axing namespaces:
+ nsfw.app
+ nsfw.repl
+ nsfw.refresher
+ nsfw.spy
+ nsfw.twitter
+ nsfw


* <2015-12-19 Sat 13:53>

Whew, been a while since I updated this. Working on SPA code structure.



  -------------------------------------------------
  v                                               ^
Event -> State (Sync / Async) -> Side Effects -> Render

Rendering is taken care of by React, so really, we're

State -> State, then multiple application functions. Should be a

How to do async?


** Assumptions

+ One atom representing app state
+ Context for things like connections / env info
+ State is updated based on previous state and context (for things like config, connections, etc). State can be synchronously calculated (returns a map), or asynchronously calculated (returns a channel).
+ Handler Types: Sync, Asyc, Side Effectful

+ Sync -> map
+ Async -> channel
+ Se -> nil (args are different)

Sync / Async params - [state params ctx]

SE params - [!state params ctx]

(fn [ctx params])

So the post-processor thing (or middleware) only works for sync /
async (and differently for those two). For side effectful handlers
there's no way to know when the processing is done

Way to cancel? Close the channel Send multiples?

Ooh, so can do multiple state updates by sending multiples to channel,
but channel will be held onto until closed?

= Pros =
+ Can handle multiple updates to state
+ is cancellable from inside (closing channel) and outside (escaping loop).

= Cons =
+ Will hold a reference to that channel until it's closed by the
  called code. Can't think of a failsafe to close from the outside.

Oh, that's interesting. What if you put another channel on the
channel. Well the state update wouldn't work but could send a tuple

[state ch]. That's super interesting. Weird at first, but still

map, vec, nil

Ugh, the return values types thing feels harmful.


Ok, converging on a good solution. The missing piece was rendering URL
off of state (I think).


Nav needs to run a handler, I think

Fuck, so clobbering state on first call vs subsequent calls. Let's see
if we can do this without expicitly derefing.

Ok, bandaided, and not so bad, just have to do subsequent ops off of
recalculated state:

(defn <admin-landing [state]
  (let [ch (chan)
        state (assoc state
                :main-view-key :landing
                :loading? true)]
    (go
      (let [{:keys [success? result]}
            (<! (data/query
                  {:companies {:type :company
                               :result :list
                               :query [:sort {:created-at 1} :limit 10]
                               :subs {:pi-count
                                      {:type :investor
                                       :result :count
                                       :query [:where {:company-id '$/_id}]}}}}))]
        (if success?
          (put! ch [(merge state result {:loading? false}) nil])
          (put! ch [(merge state {:loading? false :global-error "Couldn't get initial data"}) nil]))))
    [state ch]))


Ok, so need a way to run side-effectful code off of a state transition

For sync operations this is pretty straightforward, specify a function
to run after the state transition.

For async operations it's a bit more tricky-- there can be multiple
state transitions based on how many times a channel is sent down.

+ Don't provide an affordance for this, can be accomplished in the
  handlers themselves -- actually this isn't bad, if there's a way to
  specify a top-level post-state handler. Can try this easily.
+ Specify handler as map, with keys pointing to the state transition
  function and post-state side effectful function
+ Create a protocol


Can we wrap sync and async? I suppose.

Might need to change handlers from [arg arg arg] to {:keys [arg arg
arg]} to support middleware.

Might need to revisit the closing the channel discussion, would make
middlware much easier to write.

Otherwise can have a helper that is triggered on state changes at the
handler level whether synchronous or asynchronous.

This kind of feels like a use case for transducers, I'll have to look
into that.

Man really in the weeds on this side effect stuff.

Ok, so what did we learn?

+ Core abstractions weren't good enough
+ Page abstraction is not great for SPAs
+ URLs are UI, and should be rendered from state
+ Event -> Handler -> State -> UI only
  + Page load is an event, URL change (onpopstate) is an event.
+ Sync / Async state updates are how to think about handlers
+ Need better ways to:
  + Cause side affects off of state changes in a composable way
  + Specify
+ Code-org-wise, handlers and UI should not be combined.


Nice to have the ability to decide in-function whether or not to make
the async call.


* <2015-12-19 Sat 21:50>

Next thing to investigate, infinite scrolling. Hopefully these
abstractions will be able to handle it gracefully.

I think it's possible with the event system, just a matter of figuring
out how to specify in a good way.

Have to figure out how to handle multiple simultaneous updates (second
update call comes in when first update is in flight)

+ Infinite scrolling
+ Multiple, simultaneous updates
+ Periodic recalcs (timeago)


* <2015-12-20 Sun 14:00>

The multiple updates thing is really bugging me, basically you've got
some pretty important cases where you need to wait until all updates
are done before completing.

Basically the case I've got right now is that the intermediate updates
shouldn't be applied:

http://cl.ly/0l2v1r3N1Y1z/Screen%20Recording%202015-12-20%20at%2002.05%20PM.gif

What should happen? The last update wins, as long as it's based off of
the previous state changes, which it is. Here's the handler for
reference:

#+BEGIN_SRC clojure

(fn [state company]
  (let [errors (validate-company company)]
    (if-not (empty? errors)
      (assoc state :update-errors errors)
      (let [ch (chan)
            state (assoc state :update-loading? true)
            orig-company (:company state)
            updated-company (dissoc company
                              :pis
                              :pi-count)]
        (go
          (let [{:keys [success? obj]}
                (<! (data/mutate {:type :company
                                  :obj updated-company}))]
            (if success?
              (put! ch [(assoc state
                          :company (merge company obj)
                          :update-loading? false)
                        nil])
              (put! ch [(assoc state
                          :update-error
                          "There was a problem updating this company. Please try again."
                          :update-loading? false
                          :company orig-company)
                        nil]))))
        [(assoc state
           :company company) ch]))))

#+END_SRC

State with the updated company is immediately returned, thus the
second update that comes in works off of this updated state.

The problem is that the state may have been updated before the first
call returns. The solution is simple in the case of the first call
succeeding, we've already applied the new state, and if the update
call does not come back with any new information, we've got the
updated state. This feels leaky, though.

Ah, but we do need to return some state, which is to disable
loading. So, we do need a mechanism to prevent intermediate state
updates.

Options
+ Provide a throttle / debounce mechanism
+ Provide a way to specify rules for updates
  + Last success wins
  + Intermediate updates aren't applied
+ Counter for in-flight requests? (via context?)
  + Could use state for that too...

What if you could scope handlers to a path as well?  What if you could
return a function that would be applied to state?  Wow, this is just
getting out of hand now. But I'm going to try that, because it sounds
awesome.

Ok, the function thing worked pretty well. And by pretty well I mean
the code is a mess:

#+BEGIN_SRC clojure

(defn <update-company [state updated-company]
  (let [errors (validate-company updated-company)]
    (if-not (empty? errors)
      ;; Update errors, no backend calls.
      (assoc state :update-errors errors)

      ;; Local validations ok, proceed
      (let [ch (chan)

            prev-company (:company state)
            local-state (assoc state
                          :company updated-company
                          :update-loading? true)

            clean-updated-company (dissoc updated-company :pis :pi-count)]
        (go
          (let [{success? :success?}
                (<! (data/mutate {:type :company
                                  :obj clean-updated-company}))]
            (if success?
              (put! ch [(fn [state]
                          (assoc state :update-loading? false)) nil])
              (put! ch [(fn [state]
                          (assoc state :update-error "There was a problem updating this company. Please try again."
                            :update-loading? false
                            :company prev-company))
                        nil]))))
        [local-state ch]))))

#+END_SRC


I'm wondering if the
channel thing could be replaced with some recursive call via bus.

Shit, forgot you still need URLs on internal nav links. Need routes in
scope for that. Should put things like links in state?


* <2015-12-21 Mon 14:55>

Calling handlers from other handlers probably is not the right way to
do things.

+ Infinite scrolling
+ Multiple, simultaneous updates
+ Periodic recalcs (timeago)
+ Mutation engine delete, validations
+ Fine-grained auth for query / mutation (global auth is in).


Need to allow single thing to come off the channel. Wait, I think I
allow that already.

* <2016-10-18 Tue 22:23>

Ops bus --

Props change?

Don't pass ratoms?

Local state from closed-over ratom?
